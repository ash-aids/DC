"""
   Practical_1 - Design a distributed application using RPC for remote computation where client submits an integer value
                 to the server and server calculates factorial and returns the result to the client program."""

#rpc_server

from xmlrpc.server import SimpleXMLRPCServer

def compute_factorial(number):
    
    result = 1

    if number > 1:
        for i in range(1,number+1):
            result *= i
        return result
    
    return result

server = SimpleXMLRPCServer(("localhost",8000))

print("Server listening on port 8000")

server.register_function(compute_factorial, 'compute_factorial')
server.serve_forever()


#rpc_client


import xmlrpc.client

server = xmlrpc.client.ServerProxy("http://localhost:8000")

number = int(input("Enter an integer to compute factorial for: "))

result = server.compute_factorial(number)

print(f"The factorial of {number} is {result}")


----------------------------------------------------------------------------------------------------

"""
   Practical_2 - Design a distributed application using RMI for remote computation where client submits two strings to
                 the server and server returns the concatenation of the given strings."""


#rmi_server

import Pyro4

class  StringConcatenator:
    @Pyro4.expose
    def concatenate(self,str1,str2):
        return str1+str2
    
def start_sever():
    conacatenator =StringConcatenator()

    daemon = Pyro4.Daemon()
    url = daemon.register(conacatenator)

    print("Server URL: ",url)

    print("Server is ready.")
    daemon.requestLoop()


if __name__ == '__main__':
    start_sever()

------------------------------

#rmi_client

import Pyro4

def main():
    url = input("Enter server's url: ")

    concatenator = Pyro4.Proxy(url)

    str1 = input("Enter string 1: ")
    str2 = input("enter string 2: ")

    result = concatenator.concatenate(str1,str2)

    print("Concatenated String is: ",result)

if __name__ == "__main__":
    main()

----------------------------------------------------------------------------------------------------

'''Practical 3: Write code to simulate requests coming from clients and distribute them among the servers using the load balancing algorithms'''

import random

# List of available servers
servers = ["Server1", "Server2", "Server3"]

# Round Robin Load Balancer
class RoundRobinLoadBalancer:
    def __init__(self, servers):
        self.servers = servers
        self.current_index = 0

    def get_server(self):
        server = self.servers[self.current_index]
        self.current_index = (self.current_index + 1) % len(self.servers)
        return server

# Random Load Balancer
class RandomLoadBalancer:
    def __init__(self, servers):
        self.servers = servers

    def get_server(self):
        return random.choice(self.servers)

def simulate_requests(load_balancer, num_requests):
    for i in range(1, num_requests + 1):
        server = load_balancer.get_server()
        print(f"Request {i} routed to {server}")

if __name__ == "__main__":
    print("Round Robin Load Balancing:")
    round_robin_lb = RoundRobinLoadBalancer(servers)
    simulate_requests(round_robin_lb, 10)

    print("\nRandom Load Balancing:")
    random_lb = RandomLoadBalancer(servers)
    simulate_requests(random_lb, 10)

----------------------------------------------------------------------------------------------------

'''Practical 6: Design and develop a distributed application to find the coolest/hottest year from the available
weather data. Use weather data from the Internet and process it using MapReduce. '''



from mrjob.job import MRJob
from mrjob.step import MRStep
import csv
from datetime import datetime

class WeatherAnalysis(MRJob):
    
    def mapper_extract_temperatures(self, _, line):
        # Skip header row and empty lines
        if line.startswith('time,tavg,tmin,tmax,prcp') or not line.strip():
            return
            
        try:
            # Parse CSV line
            row = next(csv.reader([line]))
            date_str = row[0]
            tavg = float(row[1]) if row[1] else None
            
            # Only process if we have average temperature
            if tavg is not None:
                # Parse date in DD-MM-YYYY format
                date_obj = datetime.strptime(date_str, '%d-%m-%Y')
                year = date_obj.year
                
                # Emit year and temperature data
                yield year, tavg
                
        except (ValueError, IndexError, TypeError) as e:
            # Skip malformed lines
            self.increment_counter('errors', 'data_errors', 1)
            pass
    
    def reducer_avg_temperatures(self, year, temps):
        # Convert to list and filter out None values
        temps = [t for t in temps if t is not None]
        
        if temps:  # Only yield if we have valid temperatures
            avg_temp = sum(temps) / len(temps)
            yield None, (year, round(avg_temp, 2))
    
    def reducer_find_extremes(self, _, year_temp_pairs):
        years_temps = list(year_temp_pairs)
        
        if not years_temps:
            yield "Result", "No valid temperature data found"
            return
            
        if len(years_temps) == 1:
            year, avg = years_temps[0]
            yield "Single Year Analysis", f"Only data for {year} found with average temperature {avg}°C"
        else:
            # Find hottest and coolest years
            hottest_year = max(years_temps, key=lambda x: x[1])
            coolest_year = min(years_temps, key=lambda x: x[1])
            
            yield "Hottest Year", f"{hottest_year[0]} (Avg: {hottest_year[1]}°C)"
            yield "Coolest Year", f"{coolest_year[0]} (Avg: {coolest_year[1]}°C)"
    
    def steps(self):
        return [
            MRStep(mapper=self.mapper_extract_temperatures,
                   reducer=self.reducer_avg_temperatures),
            MRStep(reducer=self.reducer_find_extremes)
        ]

if __name__ == '__main__':
    WeatherAnalysis.run()

----------------------------------------------------------------------------------------------------

'''Practical 5: Design and develop a distributed Hotel booking application using Java RMI. A distributed hotel
booking system consists of the hotel server and the client machines. The server manages hotel
rooms booking information. A customer can invoke the following operations at his machine i)
Book the room for the specific guest ii) Cancel the booking of a guest.''''


#HotelBooking.java file

import java.rmi.Remote;
import java.rmi.RemoteException;

public interface HotelBooking extends Remote {
    // Book a room for a specific guest
    String bookRoom(String guestName, int roomNumber) throws RemoteException;
    
    // Cancel a booking for a specific guest
    String cancelBooking(String guestName) throws RemoteException;
    
    // Get current bookings (for demonstration)
    String listBookings() throws RemoteException;
}


#HotelBookingServer.java file

import java.rmi.RemoteException;
import java.rmi.server.UnicastRemoteObject;
import java.util.HashMap;
import java.util.Map;

public class HotelBookingServer extends UnicastRemoteObject implements HotelBooking {
    private Map<Integer, String> bookings; // room number to guest name mapping
    private static final int TOTAL_ROOMS = 10; // assuming hotel has 10 rooms
    
    public HotelBookingServer() throws RemoteException {
        super();
        bookings = new HashMap<>();
    }
    
    @Override
    public String bookRoom(String guestName, int roomNumber) throws RemoteException {
        if (roomNumber < 1 || roomNumber > TOTAL_ROOMS) {
            return "Invalid room number. Please choose between 1 and " + TOTAL_ROOMS;
        }
        
        if (bookings.containsKey(roomNumber)) {
            return "Room " + roomNumber + " is already booked by " + bookings.get(roomNumber);
        }
        
        bookings.put(roomNumber, guestName);
        return "Room " + roomNumber + " successfully booked for " + guestName;
    }
    
    @Override
    public String cancelBooking(String guestName) throws RemoteException {
        for (Map.Entry<Integer, String> entry : bookings.entrySet()) {
            if (entry.getValue().equals(guestName)) {
                bookings.remove(entry.getKey());
                return "Booking canceled for " + guestName;
            }
        }
        return "No booking found for " + guestName;
    }
    
    @Override
    public String listBookings() throws RemoteException {
        if (bookings.isEmpty()) {
            return "No current bookings";
        }
        
        StringBuilder sb = new StringBuilder();
        sb.append("Current Bookings:\n");
        for (Map.Entry<Integer, String> entry : bookings.entrySet()) {
            sb.append("Room ").append(entry.getKey()).append(": ").append(entry.getValue()).append("\n");
        }
        return sb.toString();
    }
    
    public static void main(String[] args) {
        try {
            // Create and export the server object
            HotelBookingServer server = new HotelBookingServer();
            
            // Bind the server object to the RMI registry
            java.rmi.Naming.rebind("HotelBookingService", server);
            
            System.out.println("Hotel Booking Server is ready...");
        } catch (Exception e) {
            System.err.println("Server exception: " + e.toString());
            e.printStackTrace();
        }
    }
}




#HotelBookingClient.java file

import java.rmi.Naming;
import java.util.Scanner;

public class HotelBookingClient {
    public static void main(String[] args) {
        try {
            // Look up the remote object in the RMI registry
            HotelBooking hotel = (HotelBooking) Naming.lookup("rmi://localhost/HotelBookingService");
            
            Scanner scanner = new Scanner(System.in);
            
            while (true) {
                System.out.println("\nHotel Booking System");
                System.out.println("1. Book a room");
                System.out.println("2. Cancel booking");
                System.out.println("3. View current bookings");
                System.out.println("4. Exit");
                System.out.print("Enter your choice: ");
                
                int choice = scanner.nextInt();
                scanner.nextLine(); // consume newline
                
                switch (choice) {
                    case 1:
                        System.out.print("Enter guest name: ");
                        String guestName = scanner.nextLine();
                        System.out.print("Enter room number (1-10): ");
                        int roomNumber = scanner.nextInt();
                        System.out.println(hotel.bookRoom(guestName, roomNumber));
                        break;
                    case 2:
                        System.out.print("Enter guest name to cancel booking: ");
                        String cancelName = scanner.nextLine();
                        System.out.println(hotel.cancelBooking(cancelName));
                        break;
                    case 3:
                        System.out.println(hotel.listBookings());
                        break;
                    case 4:
                        System.out.println("Exiting...");
                        scanner.close();
                        System.exit(0);
                    default:
                        System.out.println("Invalid choice");
                }
            }
        } catch (Exception e) {
            System.err.println("Client exception: " + e.toString());
            e.printStackTrace();
        }
    }
}


----------------------------------------------------------------------------------------------------
